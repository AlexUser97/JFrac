# -*- coding: utf-8 -*-
"""
This file is part of JFrac.
Realization of Pyfrac on Julia language.

"""

module HFReferenceSolutions

    include("anisotropy.jl")
    using .Anisotropy: TI_plain_strain_modulus
    
    using SpecialFunctions
    using Interpolations
    using PyPlot
    using QuadGK

    export MDR_M_vertex_solution, M_vertex_solution, Mp_vertex_solution, K_vertex_solution, Toughness_arrest, Mt_vertex_solution, KT_vertex_solution,
        LeakOff_arrest, PKN_solution, KGD_solution_K, anisotropic_toughness_elliptical_solution, TI_Elasticity_elliptical_solution_Fabrikant,
        TI_elasticity_sigma, TI_Elasticity_elliptical_solution, HF_analytical_sol, get_fracture_dimensions_analytical


    """
        Analytical solution for a radial hydraulic fracture (zero toughness case) in the Max drag reduction flow regime
        propagation, given fracture radius or the time since the start of the injection. The solution does not take leak
        off into account.

        Arguments:
        Eprime (Float64): Plain strain elastic modulus.
        Q0 (Float64): Injection rate.
        density (Float64): Fluid density.
        visc (Float64): Fluid viscosity.
        Mesh (CartesianMesh): A CartesianMesh class object describing the grid.
        R (Float64): The given radius for which the solution is evaluated.
        t (Float64): Time since the start of the injection.
        required (String): A mask giving which of the variables are required.

        Returns:
        - t (Float64) -- time at which the fracture reaches the given radius.
        - R (Float64) -- radius of the fracture at the given time.
        - p (Vector{Float64}) -- pressure at each cell when the fracture has propagated to the given radius.
        - w (Vector{Float64}) -- width opening at each cell when the fracture has propagated to the given radius or time.
        - v (Float64) -- fracture propagation velocity.
        - actvElts (Vector{Int}) -- list of cells inside the fracture at the given time.
    """

    function MDR_M_vertex_solution(Eprime, Q0, density, visc, Mesh, R=nothing, t=nothing, required="111111")
        
        fo = 1.78
        gammam = 0.758244

        if R === nothing && t === nothing
            throw(ArgumentError("Either radius or time must be provided!"))
        elseif t === nothing
            t = ((3^0.175)*(fo^0.25)*(R^2.175)*(visc^0.175)*(density^0.075))/(
                    (2^0.35)*(Eprime^0.25)*(Q0^0.675)*(gammam^2.175))
        elseif R === nothing
            R = gammam*((2^(14/87))*(Eprime^(10/87))*(Q0^(9/29))*(t^(40/87))
                        )/((3^(7/87))*(fo^(10/87))*(visc^(7/87))*density^(1/29))
        end

        actvElts = nothing
        w = nothing
        p = nothing
        v = nothing

        if required[4] == '1'
            rho = sqrt.(Mesh.CenterCoor[:, 1].^2 + Mesh.CenterCoor[:, 2].^2) / R  # normalized distance from center
            actvElts = findall(rho .<= 1)  # active cells (inside fracture)
            var1 = 1 .- rho[actvElts]

            wscale = ((3^0.16091954022988506)*(fo^0.22988505747126436)*(Q0^0.3793103448275862)*(t^0.08045977011494253)*
            (visc^0.16091954022988506)*(density^0.06896551724137931))/(
            (2^0.3218390804597701)*(Eprime^0.22988505747126436))

            w = zeros(Float64, Mesh.NumberOfElts)

            # Note: special.hyp2f1 needs to be replaced with appropriate Julia function
            # Julia has hypergeometric functions in SpecialFunctions package
            w[actvElts] = wscale * (0.916848 * (var1) .^ 0.740741 - 0.283356 * (rho[actvElts]) .^ (7/10) + 0.683013 * (
                var1) .^ 0.740741 .* rho[actvElts] - 0.500775 * (var1) .^ 0.740741 .* (rho[actvElts] .^ 2) + 1.07431 * (
                var1) .^ 0.740741 .* (rho[actvElts] .^ 3) - 1.2138 * (var1) .^ 0.740741 .* (
                rho[actvElts] .^ 4) + 0.577514 * (var1) .^ 0.740741 .* (rho[actvElts] .^ 5) - 0.502666 * (
                1 .- rho[actvElts] .^ 2) .^ 0.5 + 0.718095 * hypergeom([-7/20, 1/2], [13/20], rho[actvElts] .^ 2))
        end

        if required[3] == '1'
            rho = sqrt.(Mesh.CenterCoor[:, 1].^2 + Mesh.CenterCoor[:, 2].^2) / R  # normalized distance from center
            if actvElts === nothing
                actvElts = findall(rho .<= 1)  # active cells (inside fracture)
            end
            var1 = 1 .- rho[actvElts]

            pscale = ((3^0.2413793103448276)*(Eprime^0.6551724137931034)*(fo^0.3448275862068966)*(
                Q0^0.06896551724137931)*(visc^0.2413793103448276)*(density^0.10344827586206896))/(
                (2^0.4827586206896552)*(t^0.3793103448275862))

            p = zeros(Float64, Mesh.NumberOfElts)

            p[actvElts] = pscale * (
                0.5948935210154036 - 0.2717984030270058 ./ (var1 .^ 0.25925925925925924) + 0.23531180369007717855 / (
                rho[actvElts] .^ 0.3) - (0.16828914936530234 * rho[actvElts]) ./ (var1 .^ 0.25925925925925924) + (
                0.2225733568270942 * (rho[actvElts] .^ 2)) ./ (var1 .^ 0.25925925925925924) - (0.2158763695654084 * (
                rho[actvElts] .^ 3)) ./ (var1 .^ 0.25925925925925924) + (0.07471989686220308 * (rho[actvElts] .^ 4)) / (
                var1 .^ 0.25925925925925924))
            
            # Handle infinity values
            inf_indices = findall(isinf.(p[actvElts]))
            if length(inf_indices) > 0
                finite_values = p[actvElts][findall(isfinite.(p[actvElts]))]
                if length(finite_values) > 0
                    min_finite = minimum(finite_values)
                    max_finite = maximum(finite_values)
                    neg_inf_indices = findall(p[actvElts] .== -Inf)
                    pos_inf_indices = findall(p[actvElts] .== Inf)
                    p[actvElts][neg_inf_indices] .= min_finite
                    p[actvElts][pos_inf_indices] .= max_finite
                end
            end
        end

        if required[5] == '1'
            v = gammam * 0.45977011494252873 * (t^(0.45977011494252873-1.0)) * ((
                (2^0.16091954022988506) * (Eprime^0.11494252873563218) * (Q0^0.3103448275862069) ) /
                ((3^0.08045977011494253) * (fo^0.11494252873563218) * (visc^0.08045977011494253) * (
                density^0.034482758620689655)))
        end

        if !(required[6] == '1' && (required[3] == '1' || required[4] == '1'))  
            actvElts = nothing
        end

        return t, R, p, w, v, actvElts
    end

    # ----------------------------------------------------------------------------------------------------------------------

    """
        Analytical solution for Viscosity dominated (M vertex) fracture propagation, given fracture radius or the time
        since the start of the injection. The solution does not take leak off into account.

        Arguments:
            Eprime (Float64): Plain strain elastic modulus.
            Q0 (Float64): Injection rate.
            muPrime (Float64): 12*viscosity.
            Mesh (CartesianMesh): A CartesianMesh class object describing the grid.
            inj_point (Vector{Float64}): Injection point coordinates.
            R (Float64): The given radius for which the solution is evaluated.
            t (Float64): Time since the start of the injection.
            required (String): A mask giving which of the variables are required.

        Returns:
            - t (Float64) -- time at which the fracture reaches the given radius.
            - R (Float64) -- radius of the fracture at the given time.
            - p (Vector{Float64}) -- pressure at each cell when the fracture has propagated to the given radius.
            - w (Vector{Float64}) -- width opening at each cell when the fracture has propagated to the given radius or time.
            - v (Float64) -- fracture propagation velocity.
            - actvElts (Vector{Int}) -- list of cells inside the fracture at the given time.
    """
    function M_vertex_solution(Eprime, Q0, muPrime, Mesh, inj_point, R=nothing, t=nothing, required="111111")
        
        if R === nothing && t === nothing
            throw(ArgumentError("Either radius or time must be provided!"))
        elseif t === nothing
            t = (2.24846 * R^(9/4) * muPrime^(1/4)) / (Eprime^(1/4) * Q0^(3/4))
        elseif R === nothing
            R = (0.6976 * Eprime^(1/9) * Q0^(1/3) * t^(4/9)) / muPrime^(1/9)
        end

        v = nothing
        if required[5] == '1'
            v = (4/9) * (t^(4/9 - 1.0)) * ((0.6976 * Eprime^(1/9) * Q0^(1/3)) / muPrime^(1/9))
        end

        w = nothing
        actvElts = nothing
        if required[4] == '1'
            rho = sqrt.((Mesh.CenterCoor[:, 1] .- inj_point[1]).^2 + (Mesh.CenterCoor[:, 2] .- inj_point[2]).^2) / R  # normalized distance from center
            actvElts = findall(rho .<= 1)  # active cells (inside fracture)
            # temporary variables to avoid recomputation
            var1 = -2 .+ 2 .* rho[actvElts]
            var2 = 1 .- rho[actvElts]

            w = zeros(Float64, Mesh.NumberOfElts)
            w[actvElts] = (1 / (Eprime^(2/9))) * 0.6976 * Q0^(1/3) * t^(1/9) * muPrime^(2/9) * (
                    1.89201 * var2.^(2/3) + 0.000663163 * var2.^(2/3) .* (
                    35/9 + 80/9 * var1 + 38/9 * var1.^2) + 0.00314291 * var2.^(2/3) .* (
                    455/81 + 1235/54 * var1 + 2717/108 * var1.^2 + 5225/648 * var1.^3) + 0.000843517 * var2.^(
                    2/3) * (1820/243 + 11440/243 * var1 + 7150/81 * var1.^2 + 15400/243 * var1.^3 + (
                    59675 * var1.^4) / 3888) + 0.102366 * var2.^(2/3) * (1/3 + 13/3 * (-1 .+ 2 .* rho[actvElts])
                    ) + 0.237267 * ((1 .- rho[actvElts].^2).^(0.5) - rho[actvElts] .* acos.(rho[actvElts])))
        end

        p = nothing
        if required[3] == '1'  
            p = zeros(Float64, Mesh.NumberOfElts)
            rho = sqrt.((Mesh.CenterCoor[:, 1] .- inj_point[1]).^2 + (Mesh.CenterCoor[:, 2] .- inj_point[2]).^2) / R  # normalized distance from center
            if actvElts === nothing
                actvElts = findall(rho .<= 1)  # active cells (inside fracture)
            end
            
            # Suppress warnings (Julia doesn't have direct equivalent, but we handle infinities)
            p[actvElts] = (0.0931746 * Eprime^(2/3) * muPrime^(1/3) * (-2.20161 + 8.81828 * (1 .- rho[actvElts]
                            ).^(1/3) - 0.0195787 * rho[actvElts] - 0.171565 * rho[actvElts].^2 -
                            0.103558 * rho[actvElts].^3 + (1 .- rho[actvElts]).^(1/3) .* log.(1 ./ rho[actvElts]))
                        ) ./ (t^(1/3) * (1 .- rho[actvElts]).^(1/3))
            
            # Handle infinity values
            inf_indices = findall(isinf.(p[actvElts]))
            if length(inf_indices) > 0
                finite_values = p[actvElts][findall(isfinite.(p[actvElts]))]
                if length(finite_values) > 0
                    min_finite = minimum(finite_values)
                    max_finite = maximum(finite_values)
                    neg_inf_indices = findall(p[actvElts] .== -Inf)
                    pos_inf_indices = findall(p[actvElts] .== Inf)
                    p[actvElts][neg_inf_indices] .= min_finite
                    p[actvElts][pos_inf_indices] .= max_finite
                end
            end
        end

        if !(required[6] == '1' && (required[3] == '1' || required[4] == '1'))
            actvElts = nothing
        end

        return t, R, p, w, v, actvElts
    end
    # ----------------------------------------------------------------------------------------------------------------------

    """
        Semi-Analytical solution for Viscosity dominated (Mp vertex) pulse, given fracture radius or the time
        since the start of the injection. The solution does not take leak off into account.

        Arguments:
            Eprime (Float64): Plain strain elastic modulus.
            V0 (Float64): Finite volume injected.
            muPrime (Float64): 12*viscosity.
            Mesh (CartesianMesh): A CartesianMesh class object describing the grid.
            inj_point (Vector{Float64}): Injection point coordinates.
            R (Float64): The given radius for which the solution is evaluated.
            t (Float64): Time since the start of the injection.
            required (String): A mask giving which of the variables are required.

        Returns:
            - t (Float64) -- time at which the fracture reaches the given radius.
            - R (Float64) -- radius of the fracture at the given time.
            - p (Vector{Float64}) -- pressure at each cell when the fracture has propagated to the given radius.
            - w (Vector{Float64}) -- width opening at each cell when the fracture has propagated to the given radius or time.
            - v (Float64) -- fracture propagation velocity.
            - actvElts (Vector{Int}) -- active Elements inside the fracture.
    """
    function Mp_vertex_solution(Eprime, V0, muPrime, Mesh, inj_point, R=nothing, t=nothing, required="111111")
        
        if R === nothing && t === nothing
            throw(ArgumentError("Either radius or time must be provided!"))
        elseif t === nothing
            t = R^9 * muPrime / (0.836406^9 * Eprime * V0^3)
        elseif R === nothing
            R = 0.836406 * (Eprime * V0^3 * t / muPrime)^(1/9)
        end

        v = nothing
        if required[5] == '1'
            v = 1/9 * 0.836406 * (Eprime * V0^3 / (muPrime * t^8))^(1/9)
        end

        w = nothing
        actvElts = nothing
        if required[4] == '1'
            rho = sqrt.((Mesh.CenterCoor[:, 1] .- inj_point[1]).^2 + (Mesh.CenterCoor[:, 2] .- inj_point[2]).^2) / R  # normalized distance from center
            
            w_ana = [0.000515238, 0.00215311, 0.00379983, 0.00573971, 0.00774767, 0.00995946, 0.0122343,
                    0.0146669, 0.0171559, 0.0197746, 0.0224439, 0.0252238, 0.0280496, 0.0309718, 0.0339359,
                    0.0369856, 0.0400736, 0.0432386, 0.0464388, 0.0497089, 0.0530114, 0.0563778, 0.059774,
                    0.0632289, 0.0667115, 0.0702481, 0.0738103, 0.0774226, 0.0810585, 0.0847408, 0.088445,
                    0.0921924, 0.0959599, 0.0997676, 0.103594, 0.107458, 0.111338, 0.115254, 0.119185, 0.123149,
                    0.127127, 0.131135, 0.135157, 0.139206, 0.143267, 0.147355, 0.151452, 0.155575, 0.159706,
                    0.163861, 0.168023, 0.172206, 0.176396, 0.180606, 0.184822, 0.189055, 0.193294, 0.197548,
                    0.201807, 0.206081, 0.210357, 0.214647, 0.218939, 0.223243, 0.227548, 0.231864, 0.23618,
                    0.240506, 0.244831, 0.249165, 0.253497, 0.257836, 0.262172, 0.266515, 0.270854, 0.275199,
                    0.279539, 0.283883, 0.288222, 0.292565, 0.296901, 0.301239, 0.30557, 0.309903, 0.314227,
                    0.318552, 0.322869, 0.327185, 0.331491, 0.335796, 0.340091, 0.344384, 0.348665, 0.352944,
                    0.35721, 0.361473, 0.365723, 0.369968, 0.374201, 0.378427, 0.38264, 0.386846, 0.391037,
                    0.395221, 0.399391, 0.403552, 0.407697, 0.411833, 0.415953, 0.420063, 0.424156, 0.428238,
                    0.432303, 0.436357, 0.440393, 0.444416, 0.448421, 0.452413, 0.456385, 0.460345, 0.464284,
                    0.468209, 0.472113, 0.476003, 0.479872, 0.483725, 0.487557, 0.491372, 0.495166, 0.498942,
                    0.502696, 0.506433, 0.510146, 0.513842, 0.517513, 0.521166, 0.524795, 0.528405, 0.531989,
                    0.535555, 0.539094, 0.542614, 0.546108, 0.549581, 0.553027, 0.556453, 0.559851, 0.563228,
                    0.566577, 0.569904, 0.573204, 0.57648, 0.579729, 0.582954, 0.58615, 0.589323, 0.592467,
                    0.595586, 0.598676, 0.601741, 0.604776, 0.607786, 0.610766, 0.61372, 0.616643, 0.619541,
                    0.622407, 0.625247, 0.628055, 0.630837, 0.633586, 0.636309, 0.638999, 0.641662, 0.644291,
                    0.646893, 0.649462, 0.652003, 0.65451, 0.656989, 0.659434, 0.66185, 0.664232, 0.666585,
                    0.668903, 0.671192, 0.673446, 0.67567, 0.677859, 0.680018, 0.682142, 0.684235, 0.686293,
                    0.68832, 0.690311, 0.692271, 0.694195, 0.696088, 0.697944, 0.699769, 0.701557, 0.703313,
                    0.705033, 0.70672, 0.708371, 0.709989, 0.71157, 0.713119, 0.71463, 0.716108, 0.717549,
                    0.718957, 0.720327, 0.721664, 0.722963, 0.724229, 0.725457, 0.726651, 0.727807, 0.728929,
                    0.730013, 0.731064, 0.732075, 0.733053, 0.733992, 0.734897, 0.735763, 0.736595, 0.737389,
                    0.738147, 0.738867, 0.739553, 0.7402, 0.740812, 0.741385, 0.741923, 0.742422, 0.742887,
                    0.743312, 0.743702, 0.744054, 0.74437, 0.744647, 0.74489, 0.745093, 0.745261, 0.74539,
                    0.745483, 0.745537, 0.745555, 0.745537, 0.745483, 0.74539, 0.745261, 0.745093, 0.74489,
                    0.744647, 0.74437, 0.744054, 0.743702, 0.743312, 0.742887, 0.742422, 0.741923, 0.741385,
                    0.740812, 0.7402, 0.739553, 0.738867, 0.738147, 0.737389, 0.736595, 0.735763, 0.734897,
                    0.733992, 0.733053, 0.732075, 0.731064, 0.730013, 0.728929, 0.727807, 0.726651, 0.725457,
                    0.724229, 0.722963, 0.721664, 0.720327, 0.718957, 0.717549, 0.716108, 0.71463, 0.713119,
                    0.71157, 0.709989, 0.708371, 0.70672, 0.705033, 0.703313, 0.701557, 0.699769, 0.697944,
                    0.696088, 0.694195, 0.692271, 0.690311, 0.68832, 0.686293, 0.684235, 0.682142, 0.680018,
                    0.677859, 0.67567, 0.673446, 0.671192, 0.668903, 0.666585, 0.664232, 0.66185, 0.659434,
                    0.656989, 0.65451, 0.652003, 0.649462, 0.646893, 0.644291, 0.641662, 0.638999, 0.636309,
                    0.633586, 0.630837, 0.628055, 0.625247, 0.622407, 0.619541, 0.616643, 0.61372, 0.610766,
                    0.607786, 0.604776, 0.601741, 0.598676, 0.595586, 0.592467, 0.589323, 0.58615, 0.582954,
                    0.579729, 0.57648, 0.573204, 0.569904, 0.566577, 0.563228, 0.559851, 0.556453, 0.553027,
                    0.549581, 0.546108, 0.542614, 0.539094, 0.535555, 0.531989, 0.528405, 0.524795, 0.521166,
                    0.517513, 0.513842, 0.510146, 0.506433, 0.502696, 0.498942, 0.495166, 0.491372, 0.487557,
                    0.483725, 0.479872, 0.476003, 0.472113, 0.468209, 0.464284, 0.460345, 0.456385, 0.452413,
                    0.448421, 0.444416, 0.440393, 0.436357, 0.432303, 0.428238, 0.424156, 0.420063, 0.415953,
                    0.411833, 0.407697, 0.403552, 0.399391, 0.395221, 0.391037, 0.386846, 0.38264, 0.378427,
                    0.374201, 0.369968, 0.365723, 0.361473, 0.35721, 0.352944, 0.348665, 0.344384, 0.340091,
                    0.335796, 0.331491, 0.327185, 0.322869, 0.318552, 0.314227, 0.309903, 0.30557, 0.301239,
                    0.296901, 0.292565, 0.288222, 0.283883, 0.279539, 0.275199, 0.270854, 0.266515, 0.262172,
                    0.257836, 0.253497, 0.249165, 0.244831, 0.240506, 0.23618, 0.231864, 0.227548, 0.223243,
                    0.218939, 0.214647, 0.210357, 0.206081, 0.201807, 0.197548, 0.193294, 0.189055, 0.184822,
                    0.180606, 0.176396, 0.172206, 0.168023, 0.163861, 0.159706, 0.155575, 0.151452, 0.147355,
                    0.143267, 0.139206, 0.135157, 0.131135, 0.127127, 0.123149, 0.119185, 0.115254, 0.111338,
                    0.107458, 0.103594, 0.0997676, 0.0959599, 0.0921924, 0.088445, 0.0847408, 0.0810585,
                    0.0774226, 0.0738103, 0.0702481, 0.0667115, 0.0632289, 0.059774, 0.0563778, 0.0530114,
                    0.0497089, 0.0464388, 0.0432386, 0.0400736, 0.0369856, 0.0339359, 0.0309718, 0.0280496,
                    0.0252238, 0.0224439, 0.0197746, 0.0171559, 0.0146669, 0.0122343, 0.00995946, 0.00774767,
                    0.00573971, 0.00379983, 0.00215311, 0.000515238]
            
            coords = [0.99998, 0.999921, 0.999822, 0.999684, 0.999507, 0.999289, 0.999033, 0.998737, 0.998402,
                    0.998027, 0.997613, 0.997159, 0.996666, 0.996134, 0.995562, 0.994951, 0.994301, 0.993611,
                    0.992883, 0.992115, 0.991308, 0.990461, 0.989576, 0.988652, 0.987688, 0.986686, 0.985645,
                    0.984564, 0.983445, 0.982287, 0.981091, 0.979855, 0.978581, 0.977268, 0.975917, 0.974527,
                    0.973099, 0.971632, 0.970127, 0.968583, 0.967001, 0.965382, 0.963724, 0.962028, 0.960294,
                    0.958522, 0.956712, 0.954865, 0.952979, 0.951057, 0.949096, 0.947098, 0.945063, 0.942991,
                    0.940881, 0.938734, 0.93655, 0.934329, 0.932071, 0.929776, 0.927445, 0.925077, 0.922673,
                    0.920232, 0.917755, 0.915241, 0.912692, 0.910106, 0.907484, 0.904827, 0.902134, 0.899405,
                    0.896641, 0.893841, 0.891007, 0.888136, 0.885231, 0.882291, 0.879316, 0.876307, 0.873262,
                    0.870184, 0.867071, 0.863923, 0.860742, 0.857527, 0.854277, 0.850994, 0.847678, 0.844328,
                    0.840945, 0.837528, 0.834078, 0.830596, 0.827081, 0.823533, 0.819952, 0.816339, 0.812694,
                    0.809017, 0.805308, 0.801567, 0.797794, 0.79399, 0.790155, 0.786288, 0.782391, 0.778462,
                    0.774503, 0.770513, 0.766493, 0.762443, 0.758362, 0.754251, 0.750111, 0.745941, 0.741742,
                    0.737513, 0.733255, 0.728969, 0.724653, 0.720309, 0.715936, 0.711536, 0.707107, 0.70265,
                    0.698165, 0.693653, 0.689114, 0.684547, 0.679953, 0.675333, 0.670686, 0.666012, 0.661312,
                    0.656586, 0.651834, 0.647056, 0.642253, 0.637424, 0.63257, 0.627691, 0.622788, 0.61786,
                    0.612907, 0.60793, 0.60293, 0.597905, 0.592857, 0.587785, 0.58269, 0.577573, 0.572432,
                    0.567269, 0.562083, 0.556876, 0.551646, 0.546394, 0.541121, 0.535827, 0.530511, 0.525175,
                    0.519817, 0.51444, 0.509041, 0.503623, 0.498185, 0.492727, 0.48725, 0.481754, 0.476238,
                    0.470704, 0.465151, 0.45958, 0.45399, 0.448383, 0.442758, 0.437116, 0.431456, 0.425779,
                    0.420086, 0.414376, 0.408649, 0.402906, 0.397148, 0.391374, 0.385584, 0.379779, 0.373959,
                    0.368125, 0.362275, 0.356412, 0.350534, 0.344643, 0.338738, 0.33282, 0.326888, 0.320944,
                    0.314987, 0.309017, 0.303035, 0.297042, 0.291036, 0.285019, 0.278991, 0.272952, 0.266902,
                    0.260842, 0.254771, 0.24869, 0.242599, 0.236499, 0.230389, 0.224271, 0.218143, 0.212007,
                    0.205863, 0.19971, 0.193549, 0.187381, 0.181206, 0.175023, 0.168833, 0.162637, 0.156434,
                    0.150226, 0.144011, 0.13779, 0.131564, 0.125333, 0.119097, 0.112856, 0.106611, 0.100362,
                    0.0941083, 0.0878512, 0.0815906, 0.0753268, 0.06906, 0.0627905, 0.0565185, 0.0502443,
                    0.0439681, 0.0376902, 0.0314108, 0.0251301, 0.0188484, 0.012566, 0.00628314,
                    6.12323e-17, -0.00628314, -0.012566, -0.0188484, -0.0251301, -0.0314108, -0.0376902,
                    -0.0439681, -0.0502443, -0.0565185, -0.0627905, -0.06906, -0.0753268, -0.0815906,
                    -0.0878512, -0.0941083, -0.100362, -0.106611, -0.112856, -0.119097, -0.125333, -0.131564,
                    -0.13779, -0.144011, -0.150226, -0.156434, -0.162637, -0.168833, -0.175023, -0.181206,
                    -0.187381, -0.193549, -0.19971, -0.205863, -0.212007, -0.218143, -0.224271, -0.230389,
                    -0.236499, -0.242599, -0.24869, -0.254771, -0.260842, -0.266902, -0.272952, -0.278991,
                    -0.285019, -0.291036, -0.297042, -0.303035, -0.309017, -0.314987, -0.320944, -0.326888,
                    -0.33282, -0.338738, -0.344643, -0.350534, -0.356412, -0.362275, -0.368125, -0.373959,
                    -0.379779, -0.385584, -0.391374, -0.397148, -0.402906, -0.408649, -0.414376, -0.420086,
                    -0.425779, -0.431456, -0.437116, -0.442758, -0.448383, -0.45399, -0.45958, -0.465151,
                    -0.470704, -0.476238, -0.481754, -0.48725, -0.492727, -0.498185, -0.503623, -0.509041,
                    -0.51444, -0.519817, -0.525175, -0.530511, -0.535827, -0.541121, -0.546394, -0.551646,
                    -0.556876, -0.562083, -0.567269, -0.572432, -0.577573, -0.58269, -0.587785, -0.592857,
                    -0.597905, -0.60293, -0.60793, -0.612907, -0.61786, -0.622788, -0.627691, -0.63257,
                    -0.637424, -0.642253, -0.647056, -0.651834, -0.656586, -0.661312, -0.666012, -0.670686,
                    -0.675333, -0.679953, -0.684547, -0.689114, -0.693653, -0.698165, -0.70265, -0.707107,
                    -0.711536, -0.715936, -0.720309, -0.724653, -0.728969, -0.733255, -0.737513, -0.741742,
                    -0.745941, -0.750111, -0.754251, -0.758362, -0.762443, -0.766493, -0.770513, -0.774503,
                    -0.778462, -0.782391, -0.786288, -0.790155, -0.79399, -0.797794, -0.801567, -0.805308,
                    -0.809017, -0.812694, -0.816339, -0.819952, -0.823533, -0.827081, -0.830596, -0.834078,
                    -0.837528, -0.840945, -0.844328, -0.847678, -0.850994, -0.854277, -0.857527, -0.860742,
                    -0.863923, -0.867071, -0.870184, -0.873262, -0.876307, -0.879316, -0.882291, -0.885231,
                    -0.888136, -0.891007, -0.893841, -0.896641, -0.899405, -0.902134, -0.904827, -0.907484,
                    -0.910106, -0.912692, -0.915241, -0.917755, -0.920232, -0.922673, -0.925077, -0.927445,
                    -0.929776, -0.932071, -0.934329, -0.93655, -0.938734, -0.940881, -0.942991, -0.945063,
                    -0.947098, -0.949096, -0.951057, -0.952979, -0.954865, -0.956712, -0.958522, -0.960294,
                    -0.962028, -0.963724, -0.965382, -0.967001, -0.968583, -0.970127, -0.971632, -0.973099,
                    -0.974527, -0.975917, -0.977268, -0.978581, -0.979855, -0.981091, -0.982287, -0.983445,
                    -0.984564, -0.985645, -0.986686, -0.987688, -0.988652, -0.989576, -0.990461, -0.991308,
                    -0.992115, -0.992883, -0.993611, -0.994301, -0.994951, -0.995562, -0.996134, -0.996666,
                    -0.997159, -0.997613, -0.998027, -0.998402, -0.998737, -0.999033, -0.999289, -0.999507,
                    -0.999684, -0.999822, -0.999921, -0.99998]
            
            actvElts = findall(rho .<= maximum(coords))  # active cells (inside fracture)
            fw = linear_interpolation(coords, w_ana, extrapolation_bc=Line())
            w = zeros(Float64, Mesh.NumberOfElts)
            w[actvElts] = fw.(rho[actvElts]) * (muPrime^2 * V0^3 / (Eprime^2 * t^2))^(1/9)

            PyPlot.plot(rho[actvElts], w[actvElts])
            PyPlot.show()

        end

        p = nothing
        if required[3] == '1'
            rho = sqrt.((Mesh.CenterCoor[:, 1] .- inj_point[1]).^2 + (Mesh.CenterCoor[:, 2] .- inj_point[2]).^2) / R  # normalized distance from center
            
            p_ana = [-9.13851, -2.49865, -2.34774, -1.50283, -1.40554, -1.04922, -0.984852, -0.7835, -0.737368,
                    -0.606172, -0.571155, -0.478071, -0.450376, -0.380468, -0.357885, -0.303202, -0.284348,
                    -0.240244, -0.224208, -0.187778, -0.17393, -0.14326, -0.131151, -0.104921, -0.0942218,
                    -0.0714953, -0.0619558, -0.0420458, -0.0334749, -0.0158662, -0.00811363, 0.00758825, 0.0146419,
                    0.0287444, 0.0351955, 0.0479422, 0.0538697, 0.0654559, 0.0709249, 0.0815094, 0.0865742,
                    0.0962876, 0.100994, 0.109944, 0.114331, 0.122609, 0.126709, 0.134392, 0.138233, 0.145385,
                    0.148993, 0.15567, 0.159066, 0.165316, 0.168519, 0.174383, 0.177409, 0.182923, 0.185788,
                    0.190984, 0.193699, 0.198606, 0.201183, 0.205824, 0.208275, 0.212672, 0.215004, 0.219177,
                    0.221399, 0.225365, 0.227486, 0.23126, 0.233285, 0.236882, 0.238817, 0.242249, 0.244101,
                    0.247379, 0.249152, 0.252287, 0.253986, 0.256987, 0.258617, 0.261492, 0.263056, 0.265814,
                    0.267316, 0.269963, 0.271406, 0.27395, 0.275336, 0.277782, 0.279116, 0.28147, 0.282753,
                    0.285019, 0.286255, 0.288438, 0.289628, 0.291734, 0.29288, 0.294911, 0.296016, 0.297977,
                    0.299042, 0.300936, 0.301963, 0.303793, 0.304784, 0.306553, 0.307509, 0.30922, 0.310142,
                    0.311798, 0.312688, 0.314292, 0.315151, 0.316703, 0.317532, 0.319037, 0.319837, 0.321295,
                    0.322068, 0.323482, 0.324228, 0.325599, 0.326319, 0.327649, 0.328344, 0.329635, 0.330306,
                    0.331558, 0.332206, 0.333422, 0.334047, 0.335229, 0.335831, 0.336979, 0.33756, 0.338675,
                    0.339236, 0.340319, 0.34086, 0.341912, 0.342434, 0.343457, 0.343959, 0.344953, 0.345437,
                    0.346404, 0.346869, 0.34781, 0.348257, 0.349172, 0.349602, 0.350491, 0.350905, 0.35177,
                    0.352167, 0.353008, 0.353389, 0.354208, 0.354573, 0.355369, 0.355719, 0.356493, 0.356828,
                    0.35758, 0.3579, 0.358633, 0.358938, 0.35965, 0.359941, 0.360634, 0.360911, 0.361585, 0.361848,
                    0.362503, 0.362753, 0.363389, 0.363626, 0.364244, 0.364468, 0.365069, 0.365279, 0.365864,
                    0.366061, 0.366629, 0.366814, 0.367365, 0.367538, 0.368073, 0.368234, 0.368753, 0.368901,
                    0.369406, 0.369542, 0.370031, 0.370156, 0.37063, 0.370743, 0.371202, 0.371303, 0.371749,
                    0.371838, 0.37227, 0.372348, 0.372765, 0.372832, 0.373236, 0.373291, 0.373682, 0.373726,
                    0.374103, 0.374137, 0.374501, 0.374523, 0.374874, 0.374885, 0.375224, 0.375224, 0.37555,
                    0.375539, 0.375853, 0.375831, 0.376133, 0.3761, 0.37639, 0.376346, 0.376624, 0.37657, 0.376835,
                    0.37677, 0.377024, 0.376948, 0.37719, 0.377104, 0.377334, 0.377237, 0.377456, 0.377347,
                    0.377555, 0.377436, 0.377633, 0.377502, 0.377688, 0.377547, 0.377721, 0.377569, 0.377732,
                    0.377569, 0.377721, 0.377547, 0.377688, 0.377502, 0.377633, 0.377436, 0.377555, 0.377347,
                    0.377456, 0.377237, 0.377334, 0.377104, 0.37719, 0.376948, 0.377024, 0.37677, 0.376835, 0.37657,
                    0.376624, 0.376346, 0.37639, 0.3761, 0.376133, 0.375831, 0.375853, 0.375539, 0.37555, 0.375224,
                    0.375224, 0.374885, 0.374874, 0.374523, 0.374501, 0.374137, 0.374103, 0.373726, 0.373682,
                    0.373291, 0.373236, 0.372832, 0.372765, 0.372348, 0.37227, 0.371838, 0.371749, 0.371303,
                    0.371202, 0.370743, 0.37063, 0.370156, 0.370031, 0.369542, 0.369406, 0.368901, 0.368753,
                    0.368234, 0.368073, 0.367538, 0.367365, 0.366814, 0.366629, 0.366061, 0.365864, 0.365279,
                    0.365069, 0.364468, 0.364244, 0.363626, 0.363389, 0.362753, 0.362503, 0.361848, 0.361585,
                    0.360911, 0.360634, 0.359941, 0.35965, 0.358938, 0.358633, 0.3579, 0.35758, 0.356828, 0.356493,
                    0.355719, 0.355369, 0.354573, 0.354208, 0.353389, 0.353008, 0.352167, 0.35177, 0.350905,
                    0.350491, 0.349602, 0.349172, 0.348257, 0.34781, 0.346869, 0.346404, 0.345437, 0.344953,
                    0.343959, 0.343457, 0.342434, 0.341912, 0.34086, 0.340319, 0.339236, 0.338675, 0.33756,
                    0.336979, 0.335831, 0.335229, 0.334047, 0.333422, 0.332206, 0.331558, 0.330306, 0.329635,
                    0.328344, 0.327649, 0.326319, 0.325599, 0.324228, 0.323482, 0.322068, 0.321295, 0.319837,
                    0.319037, 0.317532, 0.316703, 0.315151, 0.314292, 0.312688, 0.311798, 0.310142, 0.30922,
                    0.307509, 0.306553, 0.304784, 0.303793, 0.301963, 0.300936, 0.299042, 0.297977, 0.296016,
                    0.294911, 0.29288, 0.291734, 0.289628, 0.288438, 0.286255, 0.285019, 0.282753, 0.28147,
                    0.279116, 0.277782, 0.275336, 0.27395, 0.271406, 0.269963, 0.267316, 0.265814, 0.263056,
                    0.261492, 0.258617, 0.256987, 0.253986, 0.252287, 0.249152, 0.247379, 0.244101, 0.242249,
                    0.238817, 0.236882, 0.233285, 0.23126, 0.227486, 0.225365, 0.221399, 0.219177, 0.215004,
                    0.212672, 0.208275, 0.205824, 0.201183, 0.198606, 0.193699, 0.190984, 0.185788, 0.182923,
                    0.177409, 0.174383, 0.168519, 0.165316, 0.159066, 0.15567, 0.148993, 0.145385, 0.138233,
                    0.134392, 0.126709, 0.122609, 0.114331, 0.109944, 0.100994, 0.0962876, 0.0865742, 0.0815094,
                    0.0709249, 0.0654559, 0.0538697, 0.0479422, 0.0351955, 0.0287444, 0.0146419, 0.00758825,
                    -0.00811363, -0.0158662, -0.0334749, -0.0420458, -0.0619558, -0.0714953, -0.0942218, -0.104921,
                    -0.131151, -0.14326, -0.17393, -0.187778, -0.224208, -0.240244, -0.284348, -0.303202, -0.357885,
                    -0.380468, -0.450376, -0.478071, -0.571155, -0.606172, -0.737368, -0.7835, -0.984852, -1.04922,
                    -1.40554, -1.50283, -2.34774, -2.49865, -9.13851]
            
            coords = [0.99998, 0.999921, 0.999822, 0.999684, 0.999507, 0.999289, 0.999033, 0.998737, 0.998402,
                    0.998027, 0.997613, 0.997159, 0.996666, 0.996134, 0.995562, 0.994951, 0.994301, 0.993611,
                    0.992883, 0.992115, 0.991308, 0.990461, 0.989576, 0.988652, 0.987688, 0.986686, 0.985645,
                    0.984564, 0.983445, 0.982287, 0.981091, 0.979855, 0.978581, 0.977268, 0.975917, 0.974527,
                    0.973099, 0.971632, 0.970127, 0.968583, 0.967001, 0.965382, 0.963724, 0.962028, 0.960294,
                    0.958522, 0.956712, 0.954865, 0.952979, 0.951057, 0.949096, 0.947098, 0.945063, 0.942991,
                    0.940881, 0.938734, 0.93655, 0.934329, 0.932071, 0.929776, 0.927445, 0.925077, 0.922673,
                    0.920232, 0.917755, 0.915241, 0.912692, 0.910106, 0.907484, 0.904827, 0.902134, 0.899405,
                    0.896641, 0.893841, 0.891007, 0.888136, 0.885231, 0.882291, 0.879316, 0.876307, 0.873262,
                    0.870184, 0.867071, 0.863923, 0.860742, 0.857527, 0.854277, 0.850994, 0.847678, 0.844328,
                    0.840945, 0.837528, 0.834078, 0.830596, 0.827081, 0.823533, 0.819952, 0.816339, 0.812694,
                    0.809017, 0.805308, 0.801567, 0.797794, 0.79399, 0.790155, 0.786288, 0.782391, 0.778462,
                    0.774503, 0.770513, 0.766493, 0.762443, 0.758362, 0.754251, 0.750111, 0.745941, 0.741742,
                    0.737513, 0.733255, 0.728969, 0.724653, 0.720309, 0.715936, 0.711536, 0.707107, 0.70265,
                    0.698165, 0.693653, 0.689114, 0.684547, 0.679953, 0.675333, 0.670686, 0.666012, 0.661312,
                    0.656586, 0.651834, 0.647056, 0.642253, 0.637424, 0.63257, 0.627691, 0.622788, 0.61786,
                    0.612907, 0.60793, 0.60293, 0.597905, 0.592857, 0.587785, 0.58269, 0.577573, 0.572432,
                    0.567269, 0.562083, 0.556876, 0.551646, 0.546394, 0.541121, 0.535827, 0.530511, 0.525175,
                    0.519817, 0.51444, 0.509041, 0.503623, 0.498185, 0.492727, 0.48725, 0.481754, 0.476238,
                    0.470704, 0.465151, 0.45958, 0.45399, 0.448383, 0.442758, 0.437116, 0.431456, 0.425779,
                    0.420086, 0.414376, 0.408649, 0.402906, 0.397148, 0.391374, 0.385584, 0.379779, 0.373959,
                    0.368125, 0.362275, 0.356412, 0.350534, 0.344643, 0.338738, 0.33282, 0.326888, 0.320944,
                    0.314987, 0.309017, 0.303035, 0.297042, 0.291036, 0.285019, 0.278991, 0.272952, 0.266902,
                    0.260842, 0.254771, 0.24869, 0.242599, 0.236499, 0.230389, 0.224271, 0.218143, 0.212007,
                    0.205863, 0.19971, 0.193549, 0.187381, 0.181206, 0.175023, 0.168833, 0.162637, 0.156434,
                    0.150226, 0.144011, 0.13779, 0.131564, 0.125333, 0.119097, 0.112856, 0.106611, 0.100362,
                    0.0941083, 0.0878512, 0.0815906, 0.0753268, 0.06906, 0.0627905, 0.0565185, 0.0502443,
                    0.0439681, 0.0376902, 0.0314108, 0.0251301, 0.0188484, 0.012566, 0.00628314,
                    6.12323e-17, -0.00628314, -0.012566, -0.0188484, -0.0251301, -0.0314108, -0.0376902,
                    -0.0439681, -0.0502443, -0.0565185, -0.0627905, -0.06906, -0.0753268, -0.0815906,
                    -0.0878512, -0.0941083, -0.100362, -0.106611, -0.112856, -0.119097, -0.125333, -0.131564,
                    -0.13779, -0.144011, -0.150226, -0.156434, -0.162637, -0.168833, -0.175023, -0.181206,
                    -0.187381, -0.193549, -0.19971, -0.205863, -0.212007, -0.218143, -0.224271, -0.230389,
                    -0.236499, -0.242599, -0.24869, -0.254771, -0.260842, -0.266902, -0.272952, -0.278991,
                    -0.285019, -0.291036, -0.297042, -0.303035, -0.309017, -0.314987, -0.320944, -0.326888,
                    -0.33282, -0.338738, -0.344643, -0.350534, -0.356412, -0.362275, -0.368125, -0.373959,
                    -0.379779, -0.385584, -0.391374, -0.397148, -0.402906, -0.408649, -0.414376, -0.420086,
                    -0.425779, -0.431456, -0.437116, -0.442758, -0.448383, -0.45399, -0.45958, -0.465151,
                    -0.470704, -0.476238, -0.481754, -0.48725, -0.492727, -0.498185, -0.503623, -0.509041,
                    -0.51444, -0.519817, -0.525175, -0.530511, -0.535827, -0.541121, -0.546394, -0.551646,
                    -0.556876, -0.562083, -0.567269, -0.572432, -0.577573, -0.58269, -0.587785, -0.592857,
                    -0.597905, -0.60293, -0.60793, -0.612907, -0.61786, -0.622788, -0.627691, -0.63257,
                    -0.637424, -0.642253, -0.647056, -0.651834, -0.656586, -0.661312, -0.666012, -0.670686,
                    -0.675333, -0.679953, -0.684547, -0.689114, -0.693653, -0.698165, -0.70265, -0.707107,
                    -0.711536, -0.715936, -0.720309, -0.724653, -0.728969, -0.733255, -0.737513, -0.741742,
                    -0.745941, -0.750111, -0.754251, -0.758362, -0.762443, -0.766493, -0.770513, -0.774503,
                    -0.778462, -0.782391, -0.786288, -0.790155, -0.79399, -0.797794, -0.801567, -0.805308,
                    -0.809017, -0.812694, -0.816339, -0.819952, -0.823533, -0.827081, -0.830596, -0.834078,
                    -0.837528, -0.840945, -0.844328, -0.847678, -0.850994, -0.854277, -0.857527, -0.860742,
                    -0.863923, -0.867071, -0.870184, -0.873262, -0.876307, -0.879316, -0.882291, -0.885231,
                    -0.888136, -0.891007, -0.893841, -0.896641, -0.899405, -0.902134, -0.904827, -0.907484,
                    -0.910106, -0.912692, -0.915241, -0.917755, -0.920232, -0.922673, -0.925077, -0.927445,
                    -0.929776, -0.932071, -0.934329, -0.93655, -0.938734, -0.940881, -0.942991, -0.945063,
                    -0.947098, -0.949096, -0.951057, -0.952979, -0.954865, -0.956712, -0.958522, -0.960294,
                    -0.962028, -0.963724, -0.965382, -0.967001, -0.968583, -0.970127, -0.971632, -0.973099,
                    -0.974527, -0.975917, -0.977268, -0.978581, -0.979855, -0.981091, -0.982287, -0.983445,
                    -0.984564, -0.985645, -0.986686, -0.987688, -0.988652, -0.989576, -0.990461, -0.991308,
                    -0.992115, -0.992883, -0.993611, -0.994301, -0.994951, -0.995562, -0.996134, -0.996666,
                    -0.997159, -0.997613, -0.998027, -0.998402, -0.998737, -0.999033, -0.999289, -0.999507,
                    -0.999684, -0.999822, -0.999921, -0.99998]
            
            if actvElts === nothing
                actvElts = findall(rho .<= maximum(coords))  # active cells (inside fracture)
            end
            
            fp = linear_interpolation(coords, p_ana, extrapolation_bc=Line())
            p = zeros(Float64, Mesh.NumberOfElts)
            p[actvElts] = fp.(rho[actvElts]) * (Eprime^2 * muPrime / t)^(1/3)

        end

        return t, R, p, w, v, actvElts
    end
    # ----------------------------------------------------------------------------------------------------------------------

    """
        Analytical solution for toughness dominated (K vertex) fracture propagation, given current radius or time. The
        solution does not take leak off into account.

        Arguments:
            Kprime (Float64): 4*(2/pi)^0.5 * K1c, where K1c is the linear-elastic plane-strain fracture toughness.
            Eprime (Float64): Plain strain elastic modulus.
            Q0 (Float64): Injection rate.
            mesh (CartesianMesh): A CartesianMesh class object describing the grid.
            inj_point (Vector{Float64}): Injection point coordinates.
            R (Float64): The given radius for which the solution is evaluated.
            t (Float64): Time since the start of the injection.
            required (String): A mask giving which of the variables are required.

        Returns:
            - t (Float64) -- time at which the fracture reaches the given radius.
            - R (Float64) -- radius of the fracture at the given time.
            - p (Vector{Float64}) -- pressure at each cell when the fracture has propagated to the given radius.
            - w (Vector{Float64}) -- width opening at each cell when the fracture has propagated to the given radius or time.
            - v (Float64) -- fracture propagation velocity.
            - actvElts (Vector{Int}) -- list of cells inside the fracture at the given time.
    """
    function K_vertex_solution(Kprime, Eprime, Q0, mesh, inj_point, R=nothing, t=nothing, required="111111")
        
        if R === nothing && t === nothing
            throw(ArgumentError("Either radius or time must be provided!"))
        elseif t === nothing
            t = 2^0.5 * Kprime * π * R^(5/2) / (3 * Eprime * Q0)
        elseif R === nothing
            R = (3 / 2^0.5 / π * Q0 * Eprime * t / Kprime)^0.4
        end

        p = nothing
        if required[3] == '1'
            p = π / 8 * (π / 12)^(1/5) * (Kprime^6 / (Eprime * Q0 * t))^(1/5) * ones(Float64, mesh.NumberOfElts)
        end

        w = nothing
        actvElts = nothing
        if required[4] == '1'
            w = zeros(Float64, mesh.NumberOfElts)
            rad = sqrt.((mesh.CenterCoor[:, 1] .- inj_point[1]).^2 + (mesh.CenterCoor[:, 2] .- inj_point[2]).^2)  # distance from center
            actvElts = findall(rad .< R)  # active cells (inside fracture)
            w[actvElts] = (3 / 8 / π)^0.2 * (Q0 * Kprime^4 * t / Eprime^4)^0.2 * (1 .- (rad[actvElts] / R).^2).^0.5
        end

        v = nothing
        if required[5] == '1'
            # todo Hack: The velocity is evaluated with time taken by the fracture to advance by one percent
            t1 = 2^0.5 * Kprime * π * (1.01 * R)^(5/2) / (3 * Eprime * Q0)
            v = 0.01 * R / (t1 - t)
        end

        if !(required[6] == '1' && (required[3] == '1' || required[4] == '1'))
            actvElts = nothing
        end

        return t, R, p, w, v, actvElts
    end
    # ----------------------------------------------------------------------------------------------------------------------

    """
        Analytical solution for the radius of arrest when the arrest is toughness dominated.
        The solution does not take leak off into account.

        Arguments:
            Kprime (Float64): 4*(2/pi)^0.5 * K1c, where K1c is the linear-elastic plane-strain fracture toughness.
            Eprime (Float64): Plain strain elastic modulus.
            V0 (Float64): Injected volume.
            mesh (CartesianMesh): A CartesianMesh class object describing the grid.
            inj_point (Vector{Float64}): The point where the injection takes place.
            required (String): A mask giving which of the variables are required.

        Returns:
            - R (Float64) -- radius of the fracture at the given time.
            - p (Vector{Float64}) -- pressure at each cell when the fracture has propagated to the given radius.
            - w (Vector{Float64}) -- width opening at each cell when the fracture has propagated to the given radius or time.
            - actvElts (Vector{Int}) -- list of cells inside the fracture at the given time.
    """
    function Toughness_arrest(Kprime, Eprime, V0, mesh, inj_point, required="111111")
        
        R = (3^2 * Eprime^2 * V0^2 / (2 * π^2 * Kprime^2))^(1/5)

        w = nothing
        actvElts = nothing
        if required[4] == '1'
            w = zeros(Float64, mesh.NumberOfElts)
            rho = sqrt.((mesh.CenterCoor[:, 1] .- inj_point[1]).^2 + (mesh.CenterCoor[:, 2] .- inj_point[2]).^2) / R  # distance from center
            actvElts = findall(rho .< 1.0)  # active cells (inside fracture)
            w[actvElts] = (3 / (8 * π))^(1/5) * (Kprime^4 * V0 / Eprime^4)^(1/5) * sqrt.(1 .- rho[actvElts].^2)
        end

        p = nothing
        if required[3] == '1'
            p = zeros(Float64, mesh.NumberOfElts)
            rho = sqrt.((mesh.CenterCoor[:, 1] .- inj_point[1]).^2 + (mesh.CenterCoor[:, 2] .- inj_point[2]).^2) / R  # distance from center
            if actvElts === nothing
                actvElts = findall(rho .< 1.0)  # active cells (inside fracture)
            end
            p[actvElts] = (π^6 / (3 * 2^17))^(1/5) * (Kprime^6 / (V0 * Eprime))^(1/5)
        end

        return nothing, R, p, w, zeros(Float64, mesh.NumberOfElts), actvElts
    end

    # -----------------------------------------------------------------------------------------------------------------------

    """
        Analytical solution for viscosity dominated (M tilde vertex) fracture propagation, given current time. The solution
        takes leak off into account.

        Arguments:
            Eprime (Float64): Plain strain elastic modulus.
            Cprime (Float64): 2*C, where C is the Carter's leak off coefficient.
            Q0 (Float64): Injection rate.
            muPrime (Float64): 12*viscosity.
            Mesh (CartesianMesh): A CartesianMesh class object describing the grid.
            inj_point (Vector{Float64}): Injection point coordinates.
            R (Float64): The given radius for which the solution is evaluated.
            t (Float64): The given time at which the solution is evaluated.
            required (String): A mask giving which of the variables are required.

        Returns:
            - t (Float64) -- time at which the fracture reaches the given radius.
            - R (Float64) -- radius of the fracture at the given time.
            - p (Vector{Float64}) -- pressure at each cell when the fracture has propagated to the given radius.
            - w (Vector{Float64}) -- width opening at each cell when the fracture has propagated to the given radius or time.
            - v (Float64) -- fracture propagation velocity.
            - actvElts (Vector{Int}) -- list of cells inside the fracture at the given time.
    """
    function Mt_vertex_solution(Eprime, Cprime, Q0, muPrime, Mesh, inj_point, R=nothing, t=nothing, required="111111")
        
        if R === nothing && t === nothing
            throw(ArgumentError("Either radius or time must be provided!"))
        elseif t === nothing
            if Cprime == 0
                throw(ArgumentError("leak off cannot be zero for Mt regime!"))
            end
            t = Cprime^2 * R^4 * π^4 / (4 * Q0^2)
        elseif R === nothing
            if Cprime == 0
                throw(ArgumentError("leak off cannot be zero for Mt regime!"))
            end
            R = (2 * Q0 / Cprime)^0.5 * t^0.25 / π
        end

        w = nothing
        actvElts = nothing
        if required[4] == '1'
            w = zeros(Float64, Mesh.NumberOfElts)
            rho = sqrt.((Mesh.CenterCoor[:, 1] .- inj_point[1]).^2 + (Mesh.CenterCoor[:, 2] .- inj_point[2]).^2) / R
            # normalized distance from center
            actvElts = findall(rho .<= 1)  # active cells (inside fracture)

            # temporary variables to avoid recomputation
            var1 = (1 .- rho[actvElts]).^0.375
            var2 = (1 .- rho[actvElts]).^0.625

            # todo: cite where the solution is taken from
            w[actvElts] = (0.07627790025007182 * Q0^0.375 * t^0.0625 * muPrime^0.25 * (
            11.40566553791626 * var2 + 7.049001601162521 * var2 .* rho[actvElts] - 0.6802327798216378 * var2 .* rho[actvElts].^2 - 
            0.828297356390819 * var2 .* rho[actvElts].^3 + var2 .* rho[actvElts].^4 + 2.350633434009811 * (1 .- rho[actvElts].^2).^0.5 - 
            2.350633434009811 * rho[actvElts] .* acos.(rho[actvElts]))) / (Cprime^0.125 * Eprime^0.25)
        end

        p = nothing
        if required[3] == '1'
            rho = sqrt.((Mesh.CenterCoor[:, 1] .- inj_point[1]).^2 + (Mesh.CenterCoor[:, 2] .- inj_point[2]).^2) / R
            # normalized distance from center
            if actvElts === nothing
                actvElts = findall(rho .<= 1)  # active cells (inside fracture)
            end

            # temporary variables to avoid recomputation
            var1 = (1 .- rho[actvElts]).^0.375
            var2 = (1 .- rho[actvElts]).^0.625

            p = zeros(Float64, Mesh.NumberOfElts)
            p[actvElts] = (0.156415 * Cprime^0.375 * Eprime^0.75 * muPrime^0.25 * (
            -1.0882178530759854 + 6.3385626500863985 * var1 - 0.07314343477396379 * rho[actvElts] - 0.21802875891750756 * 
            rho[actvElts].^2 - 0.04996007983993901 * rho[actvElts].^3 + 1.0 * var1 .* log.(1 ./ rho[actvElts]))) / (
            Q0^0.125 * var1 * t^0.1875)

            # Handle infinity values
            inf_indices = findall(isinf.(p[actvElts]))
            if length(inf_indices) > 0
                finite_values = p[actvElts][findall(isfinite.(p[actvElts]))]
                if length(finite_values) > 0
                    min_finite = minimum(finite_values)
                    max_finite = maximum(finite_values)
                    neg_inf_indices = findall(p[actvElts] .== -Inf)
                    pos_inf_indices = findall(p[actvElts] .== Inf)
                    p[actvElts][neg_inf_indices] .= min_finite
                    p[actvElts][pos_inf_indices] .= max_finite
                end
            end
        end

        v = nothing
        if required[5] == '1'
            # todo Hack: The velocity is evaluated with time taken by the fracture to advance by one percent
            t1 = Cprime^2 * (1.01 * R)^4 * π^4 / 4 / Q0^2
            v = 0.01 * R / (t1 - t)
        end

        if !(required[6] == '1' && (required[3] == '1' || required[4] == '1'))
            actvElts = nothing
        end

        return t, R, p, w, v, actvElts
    end

    # ----------------------------------------------------------------------------------------------------------------------

    """
        Analytical solution for viscosity dominated (M tilde vertex) fracture propagation, given the current time or the
        radius.

            Arguments:
                Eprime (Float64): Plain strain elastic modulus.
                Cprime (Float64): 2*C, where C is the Carter's leak off coefficient.
                Q0 (Float64): Injection rate.
                Kprime (Float64): 4*(2/pi)^0.5 * K1c, where K1c is the linear-elastic plane-strain fracture toughness.
                Mesh (CartesianMesh): A CartesianMesh class object describing the grid.
                inj_point (Vector{Float64}): Injection point coordinates.
                t (Float64): The given time for which the solution is evaluated. Either of the time or radius can be provided.
                R (Float64): The given radius for which the solution is evaluated. Either of the time or radius can be provided.
                required (String): A mask giving which of the variables are required.

            Returns:
                - t (Float64) -- time at which the fracture reaches the given radius.
                - R (Float64) -- radius of the fracture at the given time.
                - p (Vector{Float64}) -- pressure at each cell when the fracture has propagated to the given radius.
                - w (Vector{Float64}) -- width opening at each cell when the fracture has propagated to the given radius or time.
                - v (Float64) -- fracture propagation velocity.
                - actvElts (Vector{Int}) -- list of cells inside the fracture at the given time.
    """
    function KT_vertex_solution(Eprime, Cprime, Q0, Kprime, Mesh, inj_point, R=nothing, t=nothing, required="111111")
        
        if R === nothing && t === nothing
            throw(ArgumentError("Either the time or the radius is required to evaluate the solution."))
        elseif R === nothing
            if Cprime == 0
                throw(ArgumentError("leak off cannot be zero for Kt regime!"))
            end
            R = 2^0.5 * Q0^0.5 * t^(1/4) / Cprime^0.5 / π
        elseif t === nothing
            if Cprime == 0
                throw(ArgumentError("leak off cannot be zero for Kt regime!"))
            end
            t = (R * Cprime^0.5 * π / (2 * Q0)^0.5)^4
        end

        w = nothing
        actvElts = nothing
        if required[4] == '1'  
            w = zeros(Float64, Mesh.NumberOfElts)
            rho = sqrt.((Mesh.CenterCoor[:, 1] .- inj_point[1]).^2 + (Mesh.CenterCoor[:, 2] .- inj_point[2]).^2) / R
            # normalized distance from center
            actvElts = findall(rho .<= 1)  # active cells (inside fracture)
            w[actvElts] = Kprime * Q0^0.25 * (1 .- rho[actvElts]).^0.5 * t^0.125 / (2^0.25 * Cprime^0.25 * 
                                                                                Eprime * π^0.5)
        end

        p = nothing
        if required[3] == '1'  
            rho = sqrt.((Mesh.CenterCoor[:, 1] .- inj_point[1]).^2 + (Mesh.CenterCoor[:, 2] .- inj_point[2]).^2) / R
            # normalized distance from center
            if actvElts === nothing
                actvElts = findall(rho .<= 1)  # active cells (inside fracture)
            end
            p = zeros(Float64, Mesh.NumberOfElts)
            p[actvElts] = Cprime^0.25 * Kprime * π^(3/2) / (8 * 2^(3/4) * Q0^0.25 * t^0.125)
        end

        v = nothing
        if required[5] == '1'  
            # todo Hack: The velocity is evaluated with time taken by the fracture to advance by one percent
            t1 = (1.01 * R * Cprime^0.5 * π / (2 * Q0)^0.5)^4
            v = 0.01 * R / (t1 - t)
        end

        if !(required[6] == '1' && (required[3] == '1' || required[4] == '1'))  
            actvElts = nothing
        end

        return t, R, p, w, v, actvElts
    end

    # ----------------------------------------------------------------------------------------------------------------------

    """
        Numerical solution for the radius of arrest when the arrest is due to fluid leak-off.
        The solution does not depend on leak-off.

        Arguments:
            Eprime (Float64): Plain strain elastic modulus.
            Cprime (Float64): Adapted leak-off coefficient.
            V0 (Float64): Injected volume.
            muPrime (Float64): 12 * viscosity.

        Returns:
            - R (Float64) -- arrest radius of the fracture.
    """
    function LeakOff_arrest(Eprime, Cprime, V0, muPrime)
        
        R = 0.521771773755632468 * (Eprime * V0^5 / (Cprime^2 * muPrime))^(1/13)

        return nothing, R, nothing, nothing, nothing, nothing
    end

    # ----------------------------------------------------------------------------------------------------------------------

    """
        Analytical solution for height contained hydraulic fracture (PKN geometry), given current time. The solution
        does not take leak off into account.

        Arguments:
            Eprime (Float64): Plain strain elastic modulus.
            Q0 (Float64): Injection rate.
            muPrime (Float64): 12*viscosity.
            Mesh (CartesianMesh): A CartesianMesh class object describing the grid.
            h (Float64): The height of the PKN fracture.
            t (Float64): The given time for which the solution is evaluated.
            ell (Float64): Length of the PKN fracture, should be much more than height.
            inj_point (Vector{Float64}): Injection point coordinates.
            required (String): A mask giving which of the variables are required.

        Returns:
            - t (Float64) -- time at which the fracture reaches the given length.
            - ell (Float64) -- length of the fracture at the given time.
            - p (Vector{Float64}) -- pressure at each cell at the given time.
            - w (Vector{Float64}) -- width at each cell at the given time.
            - v (Float64) -- propagation velocity.
            - actvElts (Vector{Int}) -- list of cells inside the PKN fracture at the given time.
    """
    function PKN_solution(Eprime, Q0, muPrime, Mesh, h, ell=nothing, t=nothing, inj_point=nothing, required="111111")
        
        viscosity = muPrime / 12
        if ell === nothing && t === nothing
            throw(ArgumentError("Either the length or the time is required to evaluate the solution."))
        elseif ell === nothing
            # length of the fracture at the given time
            ell = 1.001 * (Q0^3 * Eprime * t^4 / (4 * π^3 * viscosity * h^4))^(1/5)
        elseif t === nothing
            t = 3.333333 * h * (ell^5 * viscosity / (Eprime * Q0^3))^(1/4)
        end

        x = range(-ell, ell, length=Int(Mesh.nx))

        anltcl_w = nothing
        actvElts = nothing
        w = nothing
        if required[4] == '1'
            # one dimensional solution for average width along the width of the PKN fracture. The solution is approximated
            # with the power of 1/3 and not evaluate with the series.
            sol_w = (π^3 * viscosity * Q0^2 * t / (Eprime * h * 8))^(1/5) * 1.326 * (1 .- abs.(x) / ell).^(1/3)
            # interpolation function to calculate width at any length.
            anltcl_w = linear_interpolation(x, sol_w, extrapolation_bc=Line())

            # cells inside the PKN fracture
            actvElts_v = findall(abs.(Mesh.CenterCoor[:, 1] .- inj_point[1]) .<= h / 2)
            actvElts_h = findall(abs.(Mesh.CenterCoor[:, 2] .- inj_point[2]) .<= ell)
            actvElts = intersect(actvElts_v, actvElts_h)

            w = zeros(Float64, Mesh.NumberOfElts)
            # calculating width across the cross section of the fracture from the average width.
            # The average width is given by the interpolation function.
            w[actvElts] = 4 / π * anltcl_w.((Mesh.CenterCoor[actvElts, 2] .- inj_point[2])) .* 
                        (1 .- 4 * (Mesh.CenterCoor[actvElts, 1] .- inj_point[1]).^2 / h^2).^0.5
        end

        p = nothing
        if required[3] == '1'
            if actvElts === nothing
                # cells inside the PKN fracture
                actvElts_v = findall(abs.(Mesh.CenterCoor[:, 1] .- inj_point[1]) .<= h / 2)
                actvElts_h = findall(abs.(Mesh.CenterCoor[:, 2] .- inj_point[2]) .<= ell)
                actvElts = intersect(actvElts_v, actvElts_h)
            end
            # calculating pressure from width
            p = zeros(Float64, Mesh.NumberOfElts)
            p[actvElts] = 2 * Eprime * anltcl_w.((Mesh.CenterCoor[actvElts, 2] .- inj_point[2])) / (π * h)
        end

        v = nothing
        if required[5] == '1'  
            # todo !!! Hack: The velocity is evaluated with time taken by the fracture to advance by one percent
            t1 = (1.01 * ell / (2 * (Q0 / 2)^3 * Eprime / π^3 / muPrime * 12 / h^4)^(1/5))^(5/4)
            v = 0.01 * ell / (t1 - t)
        end

        if !(required[6] == '1' && (required[3] == '1' || required[4] == '1'))  
            actvElts = nothing
        end

        return t, ell, p, w, v, actvElts
    end

    # ----------------------------------------------------------------------------------------------------------------------

    """
        Analytical solution plain strain hydraulic fracture (KGB geometry) in the toughness dominated regime, given current
        time or length. The solution does not take leak off into account.

        Arguments:
            Eprime (Float64): Plain strain elastic modulus.
            Q0 (Float64): Injection rate.
            Kprime (Float64): 4*(2/pi)^0.5 * K1c, where K1c is the linear-elastic plane-strain fracture toughness.
            Mesh (CartesianMesh): A CartesianMesh class object describing the grid.
            inj_point (Vector{Float64}): Injection point coordinates.
            height (Float64): The height of the KGD fracture (it should be much longer then length).
            ell (Float64): Length of fracture.
            t (Float64): The given time for which the solution is evaluated.
            required (String): A mask giving which of the variables are required.

        Returns:
            - t (Float64) -- time at which the fracture reaches the given length.
            - ell (Float64) -- length of the fracture at the given time.
            - p (Vector{Float64}) -- pressure at each cell at the given time.
            - w (Vector{Float64}) -- width at each cell at the given time.
            - v (Float64) -- propagation velocity.
            - actvElts (Vector{Int}) -- list of cells inside the KGD fracture at the given time.
    """
    function KGD_solution_K(Eprime, Q0, Kprime, Mesh, inj_point, height, ell=nothing, t=nothing, required="111111")
        
        # injection rate per unit height in one wing
        Q = Q0 / height

        if ell === nothing && t === nothing
            throw(ArgumentError("Either the length or the time is required to evaluate the solution."))
        elseif ell === nothing
            # length of the fracture at the given time
            ell = 0.932388 * (Eprime * Q * t / Kprime)^(2/3)
        elseif t === nothing
            t = 1.11072 * Kprime / Eprime / Q * ell^(3/2)
        end

        x = range(-ell, ell, length=Int(Mesh.nx))

        anltcl_w = nothing
        actvElts = nothing
        w = nothing
        if required[4] == '1'  
            # one dimensional solution for average width along the width of the PKN fracture. The solution is approximated with
            # the power of 1/3 and not evaluate with the series.
            sol_w = 0.682784 * (Kprime^2 * Q * t / Eprime^2)^(1/3) * (1 .- (abs.(x) / ell).^2).^(1/2)

            # interpolation function to calculate width at any length.
            anltcl_w = linear_interpolation(x, sol_w, extrapolation_bc=Line())

            # cells inside the PKN fracture
            actvElts_v = findall(abs.(Mesh.CenterCoor[:, 1] .- inj_point[1]) .<= height / 2)
            actvElts_h = findall(abs.(Mesh.CenterCoor[:, 2] .- inj_point[2]) .<= ell)
            actvElts = intersect(actvElts_v, actvElts_h)

            w = zeros(Float64, Mesh.NumberOfElts)
            # The average width is given by the interpolation function.
            w[actvElts] = anltcl_w.((Mesh.CenterCoor[actvElts, 2] .- inj_point[2]))
        end

        p = nothing
        if required[3] == '1'  
            if actvElts === nothing
                # cells inside the PKN fracture
                actvElts_v = findall(abs.(Mesh.CenterCoor[:, 1] .- inj_point[1]) .<= height / 2)
                actvElts_h = findall(abs.(Mesh.CenterCoor[:, 2] .- inj_point[2]) .<= ell)
                actvElts = intersect(actvElts_v, actvElts_h)
            end
            # calculating pressure from width
            p = zeros(Float64, Mesh.NumberOfElts)
            p[actvElts] = 0.183074 * (Kprime^4 / (Eprime * Q0 * t))^(1/3)
        end

        v = nothing
        if required[5] == '1'  
            # todo !!! Hack: The velocity is evaluated with time taken by the fracture to advance by one percent
            t1 = 1.11072 * Kprime / Eprime / Q * (1.01 * ell)^(3/2)
            v = 0.01 * ell / (t1 - t)
        end

        if !(required[6] == '1' && (required[3] == '1' || required[4] == '1'))  
            actvElts = nothing
        end

        return t, ell, p, w, v, actvElts
    end


    #-----------------------------------------------------------------------------------------------------------------------

    """
        Analytical solution for an elliptical fracture propagating in toughness dominated regime (see Zia and Lecampion,
        IJF, 2018).

        Arguments:
            KIc_max (Float64): The fracture toughness along the minor axis.
            KIc_min (Float64): The fracture toughness along the major axis.
            Eprime (Float64): Plain strain modulus.
            Q0 (Float64): Injection rate.
            mesh (CartesianMesh): A CartesianMesh class object describing the grid.
            inj_point (Vector{Float64}): Injection point coordinates.
            b (Float64): The given minor axis length.
            t (Float64): The given time for which the solution is evaluated.
            required (String): A mask giving which of the variables are required.

        Returns:
            - t (Float64) -- time at which the fracture reaches the given length.
            - b (Float64) -- length of the minor axis of the elliptical fracture at the given time.
            - p (Vector{Float64}) -- pressure at each cell at the given time.
            - w (Vector{Float64}) -- width at each cell at the given time.
            - v (Float64) -- propagation velocity of the fracture along the minor axis.
            - actvElts (Vector{Int}) -- list of cells inside the fracture at the given time.
    """
    function anisotropic_toughness_elliptical_solution(KIc_max, KIc_min, Eprime, Q0, mesh, inj_point, b=nothing, t=nothing, required="111111")
        
        if KIc_min === nothing
            throw(ArgumentError("Fracture toughness along both major and minor axis is to be provided! See MaterialProperties class."))
        end
        c = (KIc_min / KIc_max)^2

        if b === nothing && t === nothing
            throw(ArgumentError("Either the minor axis length or the time is required to evaluate the solution!"))
        end
        if b === nothing
            b = (Q0 * t * 3 * c * Eprime / (8 * KIc_max * π^0.5))^(2/5)
        end
        if t === nothing
            t = 8 * KIc_max * π^0.5 * b^(5/2) / (3 * c * Eprime * Q0)
        end

        p = nothing
        w = nothing
        actvElts = nothing
        if required[4] == '1' || required[3] == '1'
            a = (KIc_max / KIc_min)^2 * b
            eccentricity = (1 - b^2 / a^2)^0.5
            rho = 1 .- ((mesh.CenterCoor[:, 1] .- inj_point[1]) / a).^2 .- ((mesh.CenterCoor[:, 2] .- inj_point[2]) / b).^2
            actvElts = findall(rho .> 0)  # active cells (inside fracture)
            p = zeros(Float64, mesh.NumberOfElts)
            p[actvElts] = KIc_max * ellipe(eccentricity^2) / (π * b)^0.5
            w = zeros(Float64, mesh.NumberOfElts)
            w[actvElts] = 4 * b * p[mesh.CenterElts] / (Eprime * ellipe(eccentricity^2)) * (1 .-
                        ((mesh.CenterCoor[actvElts, 1] .- inj_point[1]) / a).^2 .- ((mesh.CenterCoor[actvElts, 2]
                                                                                    .- inj_point[2]) / b).^2).^0.5
        end

        v = nothing
        if required[5] == '1'  
            t1 = 8 * KIc_max * π^0.5 * (1.01 * b)^(5/2) / (3 * c * Eprime * Q0)
            v = 0.01 * b / (t1 - t)
        end

        if !(required[6] == '1' && (required[3] == '1' || required[4] == '1'))  
            actvElts = nothing
        end

        return t, b, p, w, v, actvElts
    end

    #-----------------------------------------------------------------------------------------------------------------------

    """
        Analytical solution for an elliptical fracture propagating in toughness dominated regime in Transverse Isotropic
        media  (see Fabrikant, 2011).

        Arguments:
            mesh (CartesianMesh): A CartesianMesh class object describing the grid.
            inj_point (Vector{Float64}): Injection point coordinates.
            gamma (Float64): Aspect ratio of the elliptical fracture in the anisotropic cases.
            Cij (Matrix{Float64}): The transverse isotropic stiffness matrix (in the canonical basis).
            Kc3 (Float64): The fracture toughness along the minor axis.
            Ep3 (Float64): The effective (see Moukhtari and Lecampion, 2019) elasticity along the minor axis.
            Q0 (Float64): Injection rate.
            t (Float64): The given time for which the solution is evaluated.
            b (Float64): The given minor axis length.
            required (String): A mask giving which of the variables are required.

        Returns:
            - t (Float64) -- time at which the fracture reaches the given length.
            - b (Float64) -- length of the minor axis of the elliptical fracture at the given time.
            - p (Vector{Float64}) -- pressure at each cell at the given time.
            - w (Vector{Float64}) -- width at each cell at the given time.
            - actvElts (Vector{Int}) -- list of cells inside the fracture at the given time.
    """
    function TI_Elasticity_elliptical_solution_Fabrikant(mesh, inj_point, gamma, Cij, Kc3, Ep3, Q0, t=nothing, b=nothing, required="111111")
        
        if b === nothing && t === nothing
            throw(ArgumentError("Either the minor axis length or time is to be provided!"))
        end
        if b === nothing
            b = (Q0 * t * 3 * Ep3 / (8 * gamma * Kc3 * π^0.5))^(2/5)
        else
            t = b^(5/2) * 8 * gamma * Kc3 * π^0.5 / (3 * Q0 * Ep3)
        end

        p = nothing
        w = nothing
        actvElts = nothing
        if required[4] == '1' || required[3] == '1'  
            a = gamma * b

            C11 = Cij[1, 1]
            C12 = Cij[1, 2]
            C13 = Cij[1, 3]
            C33 = Cij[3, 3]
            C44 = Cij[4, 4]
            C66 = Cij[6, 6]

            m1 = (-C13^2 + C11 * C33 - 2 * C13 * C44 - 2 * C44^2 + ((C13^2 - C11 * C33) * (C13^2
                        - C11 * C33 + 4 * C13 * C44 + 4 * C44^2))^0.5) / (
                            2 * (C13 * C44 + C44^2))
            m2 = (-C13^2 + C11 * C33 - 2 * C13 * C44 - 2 * C44^2 - ((C13^2 - C11 * C33) * (C13^2
                        - C11 * C33 + 4 * C13 * C44 + 4 * C44^2))^0.5) / (
                            2 * (C13 * C44 + C44^2))

            gamma3 = (C44 / C66)^0.5

            args = (Cij, gamma, m1, m2, gamma3)

            # Note: integrate.quad needs to be replaced with QuadGK integration
            sigma_intgrl, _ = quadgk(theta -> TI_elasticity_sigma(theta, args...), 0, 2*π, rtol=1e-8)

            w0 = 2 * (4 * (m2 - m1) * gamma3^2) / (C66 * sigma_intgrl)
            rho = 1 .- ((mesh.CenterCoor[:, 1] .- inj_point[1]) / a).^2 .- ((mesh.CenterCoor[:, 2] .- inj_point[2]) / b).^2
            actvElts = findall(rho .> 0)  # active cells (inside fracture)
            p = zeros(Float64, mesh.NumberOfElts)
            p[actvElts] = (4 * gamma * Kc3) / ((π * b)^0.5 * w0 * Ep3)

            u0 = w0 * p * b^2 / a

            w = zeros(Float64, mesh.NumberOfElts)
            w[actvElts] = u0[actvElts] * (1 .- ((mesh.CenterCoor[:, 1] .- inj_point[1]) / a).^2 .- (
                                            (mesh.CenterCoor[:, 2] .- inj_point[2]) / b).^2).^0.5
        end

        return t, b, p, w, nothing, actvElts, nothing
    end

    #-----------------------------------------------------------------------------------------------------------------------

    """
        Analytical solution for TI elasticity sigma function.
    """
    function TI_elasticity_sigma(theta, stiff_tensor, gamma, m1, m2, gamma3)
        
        C11 = stiff_tensor[1, 1]
        C13 = stiff_tensor[1, 3]
        C44 = stiff_tensor[4, 4]

        gamma1 = ((C44 + m1 * (C13 + C44)) / C11)^0.5
        gamma2 = ((C44 + m2 * (C13 + C44)) / C11)^0.5

        h1 = (m1 + 1) * (gamma3 * cos(theta))^2 + 2 * sin(theta)^2
        h2 = (m2 + 1) * (gamma3 * cos(theta))^2 + 2 * sin(theta)^2

        xi1 = ((gamma1 * cos(theta))^2 + sin(theta)^2)^0.5
        xi2 = ((gamma2 * cos(theta))^2 + sin(theta)^2)^0.5
        xi3 = ((gamma3 * cos(theta))^2 + sin(theta)^2)^0.5

        rgam = (gamma^2 * cos(theta)^2 + sin(theta)^2)^0.5
        dd = m2 * h1^2 * xi2 - m1 * h2^2 * xi1 + 4 * (m1 - m2) * xi2 * xi1 * xi3 * sin(theta)^2
        sigma = dd / (xi1 * xi2 * cos(theta)^2 * rgam^3)

        return sigma
    end

    #-----------------------------------------------------------------------------------------------------------------------

    """
        Analytical solution for an elliptical fracture propagating in toughness dominated regime in Transverse
        Isotropic media

        Arguments:
            mesh (CartesianMesh): A CartesianMesh class object describing the grid.
            inj_point (Vector{Float64}): Injection point coordinates.
            gamma (Float64): Aspect ratio of the elliptical fracture in the anisotropic cases.
            Cij (Matrix{Float64}): The transverse isotropic stiffness matrix (in the canonical basis).
            Kc3 (Float64): The fracture toughness along the minor axis.
            Ep3 (Float64): The effective (see Moukhtari and Lecampion, 2019) elasticity along the minor axis.
            Q0 (Float64): Injection rate.
            t (Float64): The given time for which the solution is evaluated.
            b (Float64): The given minor axis length.
            required (String): A mask giving which of the variables are required.

        Returns:
            - t (Float64) -- time at which the fracture reaches the given length.
            - b (Float64) -- length of the minor axis of the elliptical fracture at the given time.
            - p (Vector{Float64}) -- pressure at each cell at the given time.
            - w (Vector{Float64}) -- width at each cell at the given time.
            - actvElts (Vector{Int}) -- list of cells inside the fracture at the given time.
    """
    function TI_Elasticity_elliptical_solution(mesh, inj_point, gamma, Cij, Kc3, Ep3, Q0, t=nothing, b=nothing, required="111111")
        
        if b === nothing && t === nothing
            throw(ArgumentError("Either the minor axis length or time is to be provided!"))
        end
        if b === nothing
            b = (Q0 * t * 3 * Ep3 / (8 * gamma * Kc3 * π^0.5))^(2/5)
        else
            t = b^(5/2) * 8 * gamma * Kc3 * π^0.5 / (3 * Q0 * Ep3)
        end
        
        p = nothing
        w = nothing
        actvElts = nothing
        if required[4] == '1' || required[3] == '1'  
            a = gamma * b
            beta = alpha -> atan(tan(alpha) * gamma)

            # Note: Need to implement TI_plain_strain_modulus function
            t22 = alpha -> TI_plain_strain_modulus(beta(alpha), Cij) * (
                                (sin(alpha))^2 + (cos(alpha)/gamma)^2)^0.5

            # Integration using QuadGK
            T22, _ = quadgk(alpha -> t22(alpha), 0, 2*π, rtol=1e-8)
        
            w0 = 16 * (1 / gamma)^0.5 / T22
            rho = 1 .- ((mesh.CenterCoor[:, 1] .- inj_point[1]) / a).^2 .- ((mesh.CenterCoor[:, 2] .- inj_point[2]) / b).^2
            actvElts = findall(rho .> 0)  # active cells (inside fracture)
            p = zeros(Float64, mesh.NumberOfElts)
            p[actvElts] = 4 * Kc3 / ((π * a)^0.5 * w0 * Ep3)
            u0 = w0 * p * (b*a)^0.5
            w = zeros(Float64, mesh.NumberOfElts)
            w[actvElts] = u0[actvElts] * (1 .- ((mesh.CenterCoor[actvElts, 1] .- inj_point[1]) / a).^2 .- (
                                            (mesh.CenterCoor[actvElts, 2] .- inj_point[2]) / b).^2).^0.5
        end
                                                                                    
        return t, b, p, w, nothing, actvElts
    end

    #-----------------------------------------------------------------------------------------------------------------------

    """
        This function provides the analytical solution for the given parameters according to the given propagation regime

        Arguments:
            regime (String): The propagation regime. Possible options are listed in the documentation.
            mesh (CartesianMesh): A CartesianMesh class object describing the grid.
            Eprime (Float64): Plain strain modulus.
            Q0 (Float64): Injection rate.
            inj_point (Vector{Float64}): The injection point if not at the center(0,0).
            muPrime (Float64): 12*viscosity.
            Kprime (Float64): The fracture toughness (K') along the minor axis.
            Cprime (Float64): 2*C, where C is the Carter's leak off coefficient.
            length (Float64): The given length dimension.
            t (Float64): The given time for which the solution is evaluated.
            Kc_1 (Float64): The fracture toughness along the major axis.
            h (Float64): The height of the PKN fracture.
            density (Float64): The density of the injected fluid.
            Cij (Matrix{Float64}): The transverse isotropic stiffness matrix.
            gamma (Float64): Aspect ratio of the elliptical fracture.
            required (String): A mask giving which of the variables are required.
            Vinj (Float64): The total volume injected (for a finite pulse else it is nothing).

        Returns:
            - t (Float64) -- time at which the fracture reaches the given length.
            - r (Float64) -- length of the fracture at the given time.
            - p (Vector{Float64}) -- pressure at each cell at the given time.
            - w (Vector{Float64}) -- width at each cell at the given time.
            - v (Float64) -- propagation velocity.
            - actvElts (Vector{Int}) -- list of cells inside the fracture at the given time.
    """
    function HF_analytical_sol(regime, mesh, Eprime, Q0, inj_point=nothing, muPrime=nothing, Kprime=nothing, Cprime=nothing, length=nothing,
                        t=nothing, Kc_1=nothing, h=nothing, density=nothing, Cij=nothing, gamma=nothing, required="111111", Vinj=nothing)
        
        if inj_point === nothing
            inj_point = [0.0, 0.0]
        end

        if regime == "M"
            t, r, p, w, v, actvElts = M_vertex_solution(Eprime, Q0, muPrime, mesh, inj_point, length, t, required)
        elseif regime == "Mp"
            t, r, p, w, v, actvElts = Mp_vertex_solution(Eprime, Vinj, muPrime, mesh, inj_point, length, t, required)
        elseif regime == "K"
            t, r, p, w, v, actvElts = K_vertex_solution(Kprime, Eprime, Q0, mesh, inj_point, length, t, required)
        elseif regime == "Ka"
            t, r, p, w, v, actvElts = Toughness_arrest(Kprime, Eprime, Vinj, mesh, inj_point, required)
        elseif regime == "Mt"
            t, r, p, w, v, actvElts = Mt_vertex_solution(Eprime, Cprime, Q0, muPrime, mesh, inj_point, length, t, required)
        elseif regime == "Kt"
            t, r, p, w, v, actvElts = KT_vertex_solution(Eprime, Cprime, Q0, Kprime, mesh, inj_point, length, t, required)
        elseif regime == "La"
            t, r, p, w, v, actvElts = LeakOff_arrest(Eprime, Cprime, Vinj, muPrime)
        elseif regime == "PKN"
            t, r, p, w, v, actvElts = PKN_solution(Eprime, Q0, muPrime, mesh, h, length, t, inj_point, required)
        elseif regime == "KGD_K"
            t, r, p, w, v, actvElts = KGD_solution_K(Eprime, Q0, Kprime, mesh, inj_point, h, length, t, required)
        elseif regime == "MDR"
            t, r, p, w, v, actvElts = MDR_M_vertex_solution(Eprime, Q0, density, muPrime/12.0, mesh, length, t, required)
        elseif regime == "E_K"
            Kc_3 = Kprime / (32 / π)^0.5
            t, r, p, w, v, actvElts = anisotropic_toughness_elliptical_solution(Kc_3, Kc_1, Eprime, Q0, mesh, inj_point
                                                                                , length, t, required)
        elseif regime == "E_E"
            Kc_3 = Kprime / (32 / π)^0.5
            t, r, p, w, v, actvElts = TI_Elasticity_elliptical_solution(mesh, inj_point, gamma, Cij, Kc_3, Eprime, Q0, t, length,
                                                                        required)
        else
            throw(ArgumentError("The provided regime is not supported!"))
        end

        return t, r, p, w, v, actvElts
    end

    #-----------------------------------------------------------------------------------------------------------------------

    """
        This function gives the length of the fracture along the x and y axes propagating in the given regime at the given
        time.

        Arguments:
            regime (String): The propagation regime. Possible options are listed in the documentation.
            t (Float64): The given time for which the solution is evaluated.
            Eprime (Float64): Plain strain modulus.
            Q0 (Float64): Injection rate.
            muPrime (Float64): 12*viscosity.
            Kprime (Float64): The fracture toughness (K') along the minor axis.
            Cprime (Float64): 2*C, where C is the Carter's leak off coefficient.
            Kc_1 (Float64): The fracture toughness along the major axis.
            h (Float64): The height of the PKN fracture.
            density (Float64): The density of the injected fluid.
            gamma (Float64): Aspect ratio of the elliptical fracture in the anisotropic cases.
            Vinj (Float64): Injected volume of the finite pulse.

        Returns:
            - x_len (Float64) -- length of the fracture along x-axis.
            - y_len (Float64) -- length of the fracture along y-axis.
    """
    function get_fracture_dimensions_analytical(regime, t, Eprime, Q0, muPrime=nothing, Kprime=nothing, Cprime=nothing,
                        Kc_1=nothing, h=nothing, density=nothing, gamma=nothing, Vinj=nothing)
        
        if regime == "M"
            x_len = y_len = (0.6976 * Eprime^(1/9) * Q0^(1/3) * t^(4/9)) / muPrime^(1/9)
        elseif regime == "Mp"
            x_len = y_len = 0.836406 * Eprime^(1/9) * Vinj^(1/3) * t^(1/9) / muPrime^(1/9)
        elseif regime == "K"
            x_len = y_len = (3 / 2^0.5 / π * Q0 * Eprime * t / Kprime)^0.4
        elseif regime == "Ka"
            x_len = y_len = (3 / 2^(1/2) / π * Vinj * Eprime / Kprime)^(2/5)
        elseif regime == "Mt"
            x_len = y_len = (2 * Q0 / Cprime)^0.5 * t^0.25 / π
        elseif regime == "Kt"
            x_len = y_len = 2^0.5 * Q0^0.5 * t^(1/4) / Cprime^0.5 / π
        elseif regime == "La"
            x_len = y_len = 0.521771773755632468 * (Eprime * Vinj^5 / (Cprime^2 * muPrime))^(1/13)
        elseif regime == "PKN"
            x_len = 1.001 * (Q0^3 * Eprime * t^4 / (4 * π^3 * (muPrime / 12) * h^4))^(1/5)
            y_len = h / 2
        elseif regime == "KGD_K"
            x_len = 0.932388 * (Eprime * Q0 * t / Kprime)^(2/3)
            y_len = h
        elseif regime == "MDR"
            fo = 1.78
            gammam = 0.758244
            x_len = y_len = gammam * ((2^(14/87)) * (Eprime^(10/87)) * (Q0^(9/29)) * (t^(40/87))
                        ) / ((3^(7/87)) * (fo^(10/87)) * ((muPrime / 12)^(7/87)) * density^(1/29))
        elseif regime == "E_K"
            Kc_3 = Kprime / (32 / π)^0.5
            c = (Kc_1 / Kc_3)^2
            y_len = (Q0 * t * 3 * c * Eprime / (8 * Kc_3 * π^0.5))^(2/5)
            x_len = y_len / c
        elseif regime == "E_E"
            Kc_3 = Kprime / (32 / π)^0.5
            y_len = (Q0 * t * 3 * Eprime / (8 * gamma * Kc_3 * π^0.5))^(2/5)
            x_len = y_len * gamma
        else
            throw(ArgumentError("Analytical footprint for this regime not yet implemented"))
        end

        return x_len, y_len
    end

end # module HFReferenceSolutions